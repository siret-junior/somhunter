
<!-- 
This file is part of SOMHunter.

Copyright (C) 2020 František Mejzlík <frankmejzlik@gmail.com>
                   Mirek Kratochvil <exa.exa@gmail.com>
                   Patrik Veselý <prtrikvesely@gmail.com>

SOMHunter is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 2 of the License, or (at your option)
any later version.

SOMHunter is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
SOMHunter. If not, see <https://www.gnu.org/licenses/>.
-->
<script>

// Global state
let vd = {};
vd.somhunter = <%- JSON.stringify(somhunter) %>;
vd.strs = <%- JSON.stringify(strs) %>;
vd.coreCfg = <%- JSON.stringify(coreCfg) %>;
let pageId = 0;
let lastPageTime = 0;
let pageLoadSpan = 1500;
let shouldRescore = false;

function showNextTopDisplay(id, thisFilename) {
  pageId++;
  let url =
    "/get_top_screen?pageId=" +
    pageId +
    "&type=" +
    vd.somhunter.screen.type +
    "&frameId=" +
    vd.somhunter.frameContext.frameId;
  // Make the request
  fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      // Get updated view data
      oldLength = vd.somhunter.screen.frames.length;
      vd.somhunter.screen.frames = vd.somhunter.screen.frames.concat(
        data.viewData.somhunter.screen.frames
      );
      appendImageGrid(vd, oldLength);
    })
    .catch((e) => {
      pageId--;
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function showTopDisplay(type, id, thisFilename) {
  pageId = 0;

  if (type === undefined) type = "<%- strs.displayTypes.topn %>";

  let url = "/get_top_screen?pageId=" + pageId + "&type=" + type;

  if (id !== undefined) url += "&frameId=" + id;

  // Make the request
  fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      // Get updated view data
      viewData = data.viewData;
      putDocumentToState(viewData);
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function showSomDisplay() {
  pageId = 0;
  // Make the request
  fetch("/get_som_screen", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        if (data.error.code == 1) {
          setTimeout(showSomDisplay, 500);
        }
        throw Error(data.error.message);
      }

      // Get updated view data
      viewData = data.viewData;
      putDocumentToState(viewData);
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage("Working...", JSON.stringify(e.message), 5000, "w");
    });
}

function putDetailModelToState(screenData, targetId) {
  const grid = document.getElementById("videoDetailFrameGrid");
  const gridParent = grid.parentElement;
  const frames = screenData.frames;

  $(grid).empty();

  // Iterate over all the frames
  for (let i = 0; i < frames.length; ++i) {
    let likedStr = "";
    if (frames[i].liked) {
      likedStr = "liked";
    }

    let e = getThumbPrototype(likedStr,
      frames[i].id,
      frames[i].src,
      frames[i].vId);

      grid.appendChild(e);

  }

  // Scroll to the element
  const targetEl = grid.querySelector(`li[data-frame-id='${targetId}']`);
  const offsetToParent =
    targetEl.getBoundingClientRect().top -
    targetEl.offsetParent.getBoundingClientRect().top;
  gridParent.scroll({
    top: offsetToParent,
    left: 0,
    behavior: "smooth",
  });

  // Highlight the target
  targetEl.classList.add("highlighted");
}

function puReplayModelToState(screenData, targetId) {
  const grid = document.getElementById("replayWindowFrameGrid");
  const gridParent = grid.parentElement;
  const frames = screenData.frames;

  $(grid).empty();

  // Iterate over all the frames
  for (let i = 0; i < frames.length; ++i) {
    let likedStr = "";
    if (frames[i].liked) {
      likedStr = "liked";
    }

    let e = getThumbPrototype(likedStr,
      frames[i].id,
      frames[i].src,
      frames[i].vId);

      grid.appendChild(e);

  }

  const targetEl = grid.querySelector(`li[data-frame-id='${targetId}']`);
  const targetIdx = Array.from(targetEl.parentNode.children).indexOf(targetEl);

  replayOffsetY = -frameWPix * targetIdx;
  replayGrid.style.marginLeft = `${replayOffsetY}px`;

  // Highlight the target
  targetEl.classList.add("highlighted");
}

function fillInReplayStripe(id) {
  pageId = 0;
  // Make the request
  fetch("/get_frame_detail_data?frameId=" + id +"&logIt=false", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      // Get modal data
      puReplayModelToState(data, id);
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function showVideoDetail(id, thisFilename) {
  pageId = 0;
  // Make the request
  fetch("/get_frame_detail_data?frameId=" + id  +"&logIt=true", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      // Get modal data
      putDetailModelToState(data, id);
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });

    $('#modalDetail').foundation('open');
}
function rescore(targetScreen) {
  if (!shouldRescore) return;

  // Communicate with the user
  showGlobalMessage("Working...", "", 5000, "w");

  closeAllLists();

  // Get current queries
  const q0 = document.getElementById("textQueryInput0").value;
  const q1 = document.getElementById("textQueryInput1").value;

  // Request input data
  const reqData = {
    q0: q0,
    q1: q1,
  };

  // Make the request
  fetch("rescore", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(reqData),
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      clearGlobalMesssage();

      // Now request new display
      if (targetScreen == "<%- strs.displayTypes.topn %>") {
        showTopDisplay();
      } else if (targetScreen == "<%- strs.displayTypes.topnContext %>") {
        showTopDisplay("<%- strs.displayTypes.topnContext %>");
      } else {
        showSomDisplay();
      }

      //showGlobalMessage(`Rescored.`, "", 2000,"s");
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function like(el, frameId) {

  // Rescore must act
  shouldRescore = true;

  // Request input data
  const reqData = {
    frameId: frameId,
  };

  // Make the request
  fetch("/like_frame", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(reqData),
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      putFrameTolikeState(data.frameId, data.isLiked);
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function submitImage(frameId) {

  // Ensure
  if (!showEnsurePopUp(`Do you really want to submit the frame with ID ${frameId}?`))
    return;

  // Request input data
  const reqData = {
    frameId: frameId,
  };

  // Make the request
  fetch("/submit_frame", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(reqData),
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      showGlobalMessage(`Frame '${frameId}' submitted.`, "", 5000, "s");
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function resetSearchSession() {
  pageId = 0;
  // Request input data
  const reqData = {};

  // Make the request
  fetch("/reset_search_session", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(reqData),
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {
      // Handle error
      if (data.error) {
        throw Error(data.error.message);
      }

      // Now request new display
      showTopDisplay();

      showGlobalMessage("Search reset.", "", 5000, "s");
    })
    .catch((e) => {
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage("Request failed!", JSON.stringify(e.message), 5000);
    });
}

function setupPanelButtons(viewData) {
  const elBtnSom = document.getElementById("btnSom");
  const elBtnTopn = document.getElementById("btnTopn");
  const elBtnTopnCtx = document.getElementById("btnTopnCtx");

  elBtnSom.classList.remove("active");
  elBtnTopn.classList.remove("active");
  elBtnTopnCtx.classList.remove("active");

  switch (viewData.somhunter.screen.type) {
    case "<%- strs.displayTypes.som %>":
      elBtnSom.classList.add("active");
      break;

    case "<%- strs.displayTypes.topn %>":
      elBtnTopn.classList.add("active");
      break;

    case "<%- strs.displayTypes.topnContext %>":
    elBtnTopnCtx.classList.add("active");
      break;
  }
}

function setupImageGrid(viewData) {
  const elem = document.getElementById("frameGrid");
  const frames = viewData.somhunter.screen.frames;

  elem.classList.remove("topn-grid");
  elem.classList.remove("som-grid");

  if (viewData.somhunter.screen.type == "<%- strs.displayTypes.som %>") {
    elem.classList.add("som-grid");
  } else {
    elem.classList.add("topn-grid");
  }

  $(elem).empty();

  // Iterate over all the frames
  for (let i = 0; i < frames.length; ++i) {
    if (frames[i].id == null) {
      elem.appendChild(getNoThumbPrototype(frames[i].src));
      continue;
    }

    let likedStr = "";
    if (frames[i].liked) {
      likedStr = "liked";
    }

    let e = getThumbPrototype(likedStr,
      frames[i].id,
      frames[i].src,
      frames[i].vId);

    elem.appendChild(e);
  }
}

function appendImageGrid(viewData, fromIndex) {
  const elem = document.getElementById("frameGrid");
  const frames = viewData.somhunter.screen.frames;

  let elemHtml = elem.innerHTML;
  // Iterate over all the frames
  for (let i = fromIndex; i < frames.length; ++i) {
    if (frames[i].id == null) {
      elem.appendChild(getNoThumbPrototype(frames[i].src));
      continue;
    }

    let likedStr = "";
    if (frames[i].liked) {
      likedStr = "liked";
    }

    let e = getThumbPrototype(
      likedStr,
      frames[i].id,
      frames[i].src,
      frames[i].vId);

    elem.appendChild(e);
  }
}

function getNoThumbPrototype(src) {
  
  let e = document.createElement("li");
  {
    e.className = `no-frame frame-in-grid small-6 medium-4 large-2 cell`;
    e.style.backgroundImage = `url('${src}')`;
  }
  
  let frag = document.createDocumentFragment();
  frag.appendChild(e);

  return frag;
}

function getThumbPrototype(likedStr, id, src, vidId) {

  let span0 = document.createElement("span");
  {
    span0.className = "frame-id";
    span0.innerText = vidId;
  }

  let btn0 = document.createElement("a");
  {
    btn0.innerText = "✔";
    btn0.className = "button frame-in-grid-hover-btn submit-frame";
    btn0.onclick = function() { submitImage(id); event.cancelBubble = true};
    btn0.title = "Submit this frame."
  }

  let btn1 = document.createElement("a");
  {
    btn1.innerText = "Detail";
    btn1.className = "button frame-in-grid-hover-btn show-detail";
    btn1.onclick = function(e) { showVideoDetail(id, src); e.stopPropagation(); };
    btn1.title = "Show the detail of this frame."
    btn1.dataset.open = "modalDetail";
  }

  let btn2 = document.createElement("a");
  {
    btn2.innerText = "KNN";
    btn2.className = "button frame-in-grid-hover-btn show-knn";
    btn2.onclick = function() { showTopDisplay("<%- strs.displayTypes.topknn %>", id); event.cancelBubble=true; }
    btn2.title = "Show most similiar frames."
  }

  
  let e = document.createElement("li");
  {
    e.className = `frame-in-grid small-6 medium-4 large-2 cell ${likedStr}`;
    e.style.backgroundImage = `url('${src}')`;
    e.onclick = function () { like(this, id) };
    e.dataset.frameId = id;
  }
  e.appendChild(span0);
  e.appendChild(btn0);
  e.appendChild(btn1);
  e.appendChild(btn2);

  let frag = document.createDocumentFragment();
  frag.appendChild(e);

  return frag;
}

function setupQueryInputs(viewData) {
  const q0 = viewData.somhunter.textQueries.q0.value;
  const q1 = viewData.somhunter.textQueries.q1.value;

  elIn0 = document.getElementById("textQueryInput0");
  elIn1 = document.getElementById("textQueryInput1");

  elIn0.value = q0;
  elIn1.value = q1;
}

/**
 * This controls infinite scrolling.
 */
var grid = document.getElementById("frameGridWrapper");

function infiniteScroll() {
  // add more contents if user scrolled down enough and last
  // page was loaded a second before
  if (
    grid.scrollTop + 300 > grid.scrollTopMax &&
    Date.now() > lastPageTime + pageLoadSpan
  ) {
    lastPageTime = Date.now();
    if (
      vd.somhunter.screen.type == "<%- strs.displayTypes.topn %>" ||
      vd.somhunter.screen.type == "<%- strs.displayTypes.topknn %>" ||
      vd.somhunter.screen.type == "<%- strs.displayTypes.topnContext %>"
    ) {
      showNextTopDisplay();
    }
  }
}

grid.addEventListener("scroll", infiniteScroll, false);

// To avoid being stuck due to infinit scroll limit
setInterval(function() {
  grid.dispatchEvent(new Event("scroll"));
}, 2000);

/**
 * This function modifies current page HTML according to state data.
 */
function putDocumentToState(viewData) {
  // -----------------------------
  // Manage image grid
  setupImageGrid(viewData);

  // -----------------------------
  // Change buttons
  setupPanelButtons(viewData);

  // -----------------------------
  // Setup query inputs
  setupQueryInputs(viewData);

  // Scroll to the top
  $("#frameGridWrapper").animate(
    {
      scrollTop: $("#offCanvasLeftSplit1").offset().top,
    },
    500
  );

  // -----------------------------
  // Set state
  vd = viewData;
}

/** Returns true if global keybinds can take action (e.g. no text input is active). */
function globalKeysCanPoll() {
  const el1 = document.getElementById("textQueryInput0");
  const el2 = document.getElementById("textQueryInput1");

  if (el1 == document.activeElement
  || el2 == document.activeElement) {
    return false;
  }
  return true;
}

$(document).keyup(function(e) {

  // Priority keys

  // Escape
  if (e.key === "Escape") { 
    closeAllLists();
    document.body.focus();
  } 
  // Enter key
  else if (e.key === "Enter") {
    
    if (ignoreNextEnter){
      ignoreNextEnter = false;
    } else {
      rescore("<%- strs.displayTypes.topnContext %>");
    }

  }
  // Tab
  else if (e.key === "Tab") { 
      closeAllLists();

      // Tab only cycles between the 
      const el1 = document.getElementById("textQueryInput0");
      const el2 = document.getElementById("textQueryInput1");

      if (document.activeElement != el1 && document.activeElement != el2) el1.focus();
    }

  if (!globalKeysCanPoll()) {
    return;
  }

  // Low prio keys

  // Detect escape
  if (e.key === "Escape") { 
    handleEscapeKey();
  // T key
  } else if (e.keyCode === 84) {
    
    if (e.shiftKey) {
      showTopDisplay("<%- strs.displayTypes.topn %>");
    } else {
      showTopDisplay("<%- strs.displayTypes.topnContext %>");
    }
      

  // S key
  } else if (e.keyCode === 83) {
    showSomDisplay();
  }
  
});

function handleEscapeKey() {
  // Hide replay stripe
  replayStripe.classList.remove("active");
}

function handleVideoReplayAction(frameId, deltaX) {
  const now = Date.now();
  if (lastReplayLog + scrollLogTimeout < now) {
    handleLogScroll("<%- strs.displayTypes.replay %>", frameId, deltaX);
    lastReplayLog = Date.now();
  }
}


function handleLogTextQueryChange(query) {
  let url =`/log_text_query_change?query=${query}`;

  // Make the request
  fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {  })
    .catch((e) => {
      
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Log query change request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });
}

function handleTextQueryChange() {

  // Rescore must act
  shouldRescore = true;

  const now = Date.now();
  if (lastQueryLog + scrollLogTimeout < now) {

    const val0 = document.getElementById("textQueryInput0").value
    const val1 = document.getElementById("textQueryInput1").value

    handleLogTextQueryChange(`${val0} << ${val1}`);
    lastQueryLog = Date.now();
  }
}

function getScreenType() {
  return vd.somhunter.screen.type;
}

function getCursorHitElem() {
  const elems = document.querySelectorAll(":hover"); 

  const topElem = elems[elems.length - 1];

  let scrollArea = null;
  let elem = topElem;
  while(elem = elem.parentElement) {
    if (elem.id == "modalDetail")
    {
      scrollArea = "<%- strs.displayTypes.detail %>";
      break;
    }

    if (elem.id == "frameGridWrapper"){
      scrollArea = getScreenType();
    }
    
  }
  

  return {topElem: topElem, scrollArea: scrollArea };
}

let workingFlag = false;

function setWorkingState(){
  if (workingFlag) {
    return  false;
  }
  workingFlag = true;
  return true;
}

function unsetWorkingState(){
  const tmp = workingFlag;
  workingFlag = true;
  return tmp;
}



/*********************************
 * Scroll handlers' state
 *********************************/
const scrollLogTimeout = <%- coreCfg.submitter_config.log_action_timeout %>;
let lastScrollLog = Date.now();
let lastReplayLog = Date.now();
let lastQueryLog = Date.now();
let lastScrollPos = 0;

/*********************************
 * Replay handlers' state
 *********************************/
const replayStripe = document.getElementById("replayWindow");
const replayGrid = document.getElementById("replayWindowFrameGrid");
let prevFrameId = null;
let replayOffsetY = 0;
const scrollSpeed = 100;
const frameWPerc = 12.3;
let frameWPix = window.innerWidth * (frameWPerc / 100);

function frameShiftMouseScrollHandler(event, elem) {
  if (!elem.classList.contains("frame-in-grid")){
      return;
    }
    replayStripe.classList.add("active");

    // Get cursor pos in the window
    const curX = event.clientX;
    const curY = event.clientY;

    const vpH = window.innerHeight;
    const vpW = window.innerWidth;
    const halfVpH = vpH / 2;

    frameWPix = window.innerWidth * (frameWPerc / 100);
    
    const frameId = Number(elem.dataset.frameId);
    let delta = 0;
    // Adjust the offset
    if (
      event.originalEvent.wheelDelta > 0 ||
      event.originalEvent.detail < 0
    ) { 
      // scroll up
      replayOffsetY += scrollSpeed;
      delta = -scrollSpeed;
    } else {
      // scroll down
      replayOffsetY -= scrollSpeed;
      delta = scrollSpeed;
    }

    // If frame changed => reset pos
    if (frameId !== prevFrameId) {
      fillInReplayStripe(frameId);
      prevFrameId = frameId;
    } else {
      replayGrid.style.marginLeft = `${replayOffsetY}px`;
    }

    handleVideoReplayAction(frameId, delta);

    // Position the stripe
    replayStripe.style.left = 0;
    if (curY > halfVpH)
    {
      replayStripe.style.top = 0;
      replayStripe.style.bottom = "initial";
    } else {
      replayStripe.style.top = "initial";
      replayStripe.style.bottom = 0;
    }
}

function frameMouseScrollHandler(event) 
{
  // Get cursor hit
  const {topElem, scrollArea} = getCursorHitElem();

  // If a SHIFT key is down
  if (event.shiftKey) {
    frameShiftMouseScrollHandler(event, topElem);    
    return;
  }

  // If scrolling in area of no interest
  if (scrollArea === null){
    return;
  }

  handleScrollMain(event, scrollArea);
}

function handleScrollMain(event, scrollArea) {
   
  const now = Date.now();
  if (lastScrollLog + scrollLogTimeout < now) {

    let delta = 0;
    if (
      event.originalEvent.wheelDelta > 0 ||
      event.originalEvent.detail < 0
    ) { 
      // scroll up
      delta = scrollSpeed;
    } else {
      // scroll down
      delta = -scrollSpeed;
    }

    handleLogScroll(scrollArea, null, delta);
    lastScrollLog = Date.now();
  }
}

function handleLogScroll(scrollArea, frameId = null, delta) {
  
  // Ignore SOM for now
  if (scrollArea == "<%- strs.displayTypes.som %>") {
    return;
  }

  let url =
    `/log_scroll?scrollArea=${scrollArea}&frameId=${frameId}&delta=${delta}`;
  // Make the request
  fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
  })
    .then((res) => {
      if (!res.ok) {
        throw Error(res.statusText);
      }
      return res.json();
    })
    .then((data) => {  })
    .catch((e) => {
      
      console.log("Error: " + JSON.stringify(e.message));
      showGlobalMessage(
        "Log scroll request failed!",
        JSON.stringify(e.message),
        5000,
        "e"
      );
    });

}

function putFrameTolikeState(frameId, liked) {
  const elems = document.querySelectorAll(`li[data-frame-id='${frameId}']`);
  if (liked) {
    elems.forEach(function(el) {el.classList.add("liked")})
  } else {
    elems.forEach(function(el) {el.classList.remove("liked")})
  }
}

/** Put document into correct state */
onDocumentReady(function () {
  putDocumentToState(vd);

  $(document).bind("mousewheel DOMMouseScroll", frameMouseScrollHandler);

  // Rewrite foundation tabindices
  document.getElementById("openHelpBtn").tabIndex = -1;
  document.getElementById("dataToolsBtn").tabIndex = -1;


  document.getElementById("textQueryInput0").oninput = handleTextQueryChange;
  document.getElementById("textQueryInput1").oninput = handleTextQueryChange;
  
});

</script>
